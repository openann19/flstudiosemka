/**
 * Build script to generate 909 drum samples and export as TypeScript module
 * Run this script before building the application
 * @module scripts/generate-909-samples
 */

import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// Import the generator (we'll need to create a Node.js compatible version)
// For now, we'll use a simplified approach that works in Node.js

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Simple AudioContext polyfill for Node.js
 */
class NodeAudioContext {
  sampleRate: number;

  constructor(options?: { sampleRate?: number }) {
    this.sampleRate = options?.sampleRate || 44100;
  }

  createBuffer(channels: number, length: number, sampleRate: number): AudioBuffer {
    return {
      length,
      sampleRate,
      numberOfChannels: channels,
      duration: length / sampleRate,
      getChannelData: (channel: number) => {
        if (!this.buffers) {
          this.buffers = [];
          for (let i = 0; i < channels; i += 1) {
            this.buffers.push(new Float32Array(length));
          }
        }
        return this.buffers[channel];
      },
    } as AudioBuffer & { buffers?: Float32Array[] };
  }
}

/**
 * Generate all 909 samples and export as TypeScript module
 */
async function generateSamples(): Promise<void> {
  try {
    // Create AudioContext (polyfill for Node.js)
    const AudioContext = (globalThis as { AudioContext?: typeof NodeAudioContext }).AudioContext || NodeAudioContext;
    const audioContext = new AudioContext({ sampleRate: 44100 }) as unknown as AudioContext;

    // Dynamically import the generator
    const generatorPath = join(__dirname, '../src/audio/drums/DrumSampleGenerator.ts');
    
    // Since we can't directly import TypeScript in Node.js without compilation,
    // we'll inline the generation logic here for the build script
    // In production, this would use a compiled version or ts-node
    
    // For now, create a simplified version that generates samples
    const samples = await generateAllSamples(audioContext);

    // Convert to base64 WAV strings
    const sampleData = samples.map((sample) => ({
      metadata: sample.metadata,
      wavBase64: audioBufferToWav(sample.buffer),
    }));

    // Generate TypeScript module
    const outputPath = join(__dirname, '../src/audio/drums/generated/909-samples.ts');
    const outputDir = dirname(outputPath);
    
    // Ensure directory exists
    mkdirSync(outputDir, { recursive: true });

    // Generate TypeScript file
    const tsContent = `/**
 * Pre-generated 909 Techno Drum Samples
 * This file is auto-generated by scripts/generate-909-samples.ts
 * DO NOT EDIT MANUALLY
 */

export interface DrumSampleData {
  metadata: {
    name: string;
    type: 'kick' | 'snare' | 'hihat' | 'openhat' | 'crash' | 'ride' | 'rimshot' | 'clap';
    category: string;
    velocity?: 'soft' | 'medium' | 'hard';
    description?: string;
  };
  wavBase64: string;
}

export const DRUM_SAMPLES: DrumSampleData[] = ${JSON.stringify(sampleData, null, 2)};

export const SAMPLE_COUNT = ${sampleData.length};
`;

    writeFileSync(outputPath, tsContent, 'utf-8');

     
    console.log(`‚úÖ Generated ${sampleData.length} drum samples`);
     
    console.log(`üìÅ Output: ${outputPath}`);
  } catch (error) {
     
    console.error('‚ùå Error generating samples:', error);
    process.exit(1);
  }
}

/**
 * Generate all samples (simplified version for build script)
 */
async function generateAllSamples(audioContext: AudioContext): Promise<Array<{ metadata: unknown; buffer: AudioBuffer }>> {
  const samples: Array<{ metadata: unknown; buffer: AudioBuffer }> = [];

  // Generate kicks
  samples.push(...generateKicks(audioContext));
  
  // Generate snares
  samples.push(...generateSnares(audioContext));
  
  // Generate hi-hats
  samples.push(...generateHiHats(audioContext));
  
  // Generate crashes
  samples.push(...generateCrashes(audioContext));
  
  // Generate rides
  samples.push(...generateRides(audioContext));
  
  // Generate rimshots
  samples.push(...generateRimshots(audioContext));
  
  // Generate claps
  samples.push(...generateClaps(audioContext));

  return samples;
}

/**
 * Generate kick drums
 */
function generateKicks(audioContext: AudioContext): Array<{ metadata: unknown; buffer: AudioBuffer }> {
  const kicks: Array<{ metadata: unknown; buffer: AudioBuffer }> = [];
  const variations = [
    { name: 'Deep 909', pitch: 50, decay: 0.3, punch: 0.8 },
    { name: 'Punchy 909', pitch: 60, decay: 0.15, punch: 1.0 },
    { name: 'Short 909', pitch: 65, decay: 0.1, punch: 0.9 },
    { name: 'Long 909', pitch: 55, decay: 0.5, punch: 0.7 },
    { name: 'Sub 909', pitch: 40, decay: 0.4, punch: 0.6 },
    { name: 'Tight 909', pitch: 70, decay: 0.08, punch: 1.1 },
    { name: 'Fat 909', pitch: 52, decay: 0.35, punch: 0.85 },
    { name: 'Hard 909', pitch: 58, decay: 0.12, punch: 1.2 },
    { name: 'Soft 909', pitch: 62, decay: 0.25, punch: 0.65 },
    { name: 'Classic 909', pitch: 57, decay: 0.2, punch: 0.95 },
    { name: 'Techno 909', pitch: 54, decay: 0.28, punch: 0.9 },
  ];

  for (const variation of variations) {
    kicks.push({
      metadata: { name: variation.name, type: 'kick', category: 'Kicks' },
      buffer: generateKick(audioContext, variation),
    });
  }

  return kicks;
}

/**
 * Generate kick
 */
function generateKick(
  audioContext: AudioContext,
  params: { pitch: number; decay: number; punch: number }
): AudioBuffer {
  const duration = 0.5;
  const sampleRate = audioContext.sampleRate;
  const length = Math.floor(sampleRate * duration);
  const buffer = audioContext.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);

  const attackTime = 0.001;
  const decayTime = params.decay;
  const sustainLevel = 0.1;
  const releaseTime = 0.1;

  for (let i = 0; i < length; i += 1) {
    const t = i / sampleRate;
    let sample = 0;

    const pitchEnv = Math.exp(-t * 8);
    const freq = params.pitch * (1 + pitchEnv * 2);
    const phase = (freq * t * Math.PI * 2) % (Math.PI * 2);
    sample += Math.sin(phase) * params.punch;
    sample += Math.sin(phase * 2) * 0.3 * params.punch;
    sample += Math.sin(phase * 3) * 0.15 * params.punch;

    let envelope = 1.0;
    if (t < attackTime) {
      envelope = t / attackTime;
    } else if (t < attackTime + decayTime) {
      envelope = 1.0 - ((t - attackTime) / decayTime) * (1.0 - sustainLevel);
    } else if (t < attackTime + decayTime + releaseTime) {
      const releaseProgress = (t - attackTime - decayTime) / releaseTime;
      envelope = sustainLevel * (1.0 - releaseProgress);
    } else {
      envelope = 0;
    }

    sample = Math.tanh(sample * 1.2) * envelope;
    data[i] = sample;
  }

  return buffer;
}

/**
 * Generate snares
 */
function generateSnares(audioContext: AudioContext): Array<{ metadata: unknown; buffer: AudioBuffer }> {
  const snares: Array<{ metadata: unknown; buffer: AudioBuffer }> = [];
  const variations = [
    { name: 'Fat 909', tone: 200, noise: 0.7, decay: 0.2 },
    { name: 'Tight 909', tone: 250, noise: 0.6, decay: 0.12 },
    { name: 'Crisp 909', tone: 300, noise: 0.8, decay: 0.15 },
    { name: 'Reverb 909', tone: 220, noise: 0.65, decay: 0.4 },
    { name: 'Hard 909', tone: 280, noise: 0.75, decay: 0.1 },
    { name: 'Soft 909', tone: 180, noise: 0.55, decay: 0.25 },
    { name: 'Classic 909', tone: 210, noise: 0.68, decay: 0.18 },
    { name: 'Punchy 909', tone: 240, noise: 0.72, decay: 0.14 },
    { name: 'Long 909', tone: 200, noise: 0.7, decay: 0.35 },
    { name: 'Short 909', tone: 260, noise: 0.65, decay: 0.08 },
    { name: 'Techno 909', tone: 230, noise: 0.7, decay: 0.16 },
  ];

  for (const variation of variations) {
    snares.push({
      metadata: { name: variation.name, type: 'snare', category: 'Snares' },
      buffer: generateSnare(audioContext, variation),
    });
  }

  return snares;
}

/**
 * Generate snare
 */
function generateSnare(
  audioContext: AudioContext,
  params: { tone: number; noise: number; decay: number }
): AudioBuffer {
  const duration = 0.3;
  const sampleRate = audioContext.sampleRate;
  const length = Math.floor(sampleRate * duration);
  const buffer = audioContext.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);

  const attackTime = 0.001;
  const decayTime = params.decay;
  const releaseTime = 0.05;

  let noiseSeed = Math.random() * 1000;

  for (let i = 0; i < length; i += 1) {
    const t = i / sampleRate;
    let sample = 0;

    const toneFreq = params.tone;
    const tonePhase = (toneFreq * t * Math.PI * 2) % (Math.PI * 2);
    const toneEnv = Math.exp(-t * 15);
    sample += Math.sin(tonePhase) * toneEnv * (1 - params.noise);

    noiseSeed = (noiseSeed * 9301 + 49297) % 233280;
    const noise = (noiseSeed / 233280) * 2 - 1;
    const noiseEnv = Math.exp(-t * 8);
    sample += noise * params.noise * noiseEnv;

    let envelope = 1.0;
    if (t < attackTime) {
      envelope = t / attackTime;
    } else if (t < attackTime + decayTime) {
      envelope = Math.exp(-(t - attackTime) * 8);
    } else if (t < attackTime + decayTime + releaseTime) {
      envelope = Math.exp(-(t - attackTime) * 8) * (1.0 - (t - attackTime - decayTime) / releaseTime);
    } else {
      envelope = 0;
    }

    sample *= envelope;
    data[i] = Math.max(-1, Math.min(1, sample));
  }

  return buffer;
}

/**
 * Generate hi-hats
 */
function generateHiHats(audioContext: AudioContext): Array<{ metadata: unknown; buffer: AudioBuffer }> {
  const hihats: Array<{ metadata: unknown; buffer: AudioBuffer }> = [];
  const variations = [
    { name: 'Closed HH', type: 'hihat', pitch: 8000, decay: 0.05, brightness: 0.8 },
    { name: 'Open HH', type: 'openhat', pitch: 6000, decay: 0.2, brightness: 0.7 },
    { name: 'Pedal HH', type: 'hihat', pitch: 4000, decay: 0.08, brightness: 0.5 },
    { name: 'Shaker HH', type: 'hihat', pitch: 7000, decay: 0.12, brightness: 0.75 },
    { name: 'Bright HH', type: 'hihat', pitch: 9000, decay: 0.06, brightness: 0.9 },
    { name: 'Dark HH', type: 'hihat', pitch: 5000, decay: 0.1, brightness: 0.6 },
    { name: 'Short HH', type: 'hihat', pitch: 7500, decay: 0.03, brightness: 0.85 },
    { name: 'Long HH', type: 'hihat', pitch: 6500, decay: 0.25, brightness: 0.7 },
  ];

  for (const variation of variations) {
    hihats.push({
      metadata: { name: variation.name, type: variation.type as 'hihat' | 'openhat', category: 'HiHats' },
      buffer: generateHiHat(audioContext, variation),
    });
  }

  return hihats;
}

/**
 * Generate hi-hat
 */
function generateHiHat(
  audioContext: AudioContext,
  params: { pitch: number; decay: number; brightness: number }
): AudioBuffer {
  const duration = 0.2;
  const sampleRate = audioContext.sampleRate;
  const length = Math.floor(sampleRate * duration);
  const buffer = audioContext.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);

  const attackTime = 0.001;
  const decayTime = params.decay;

  let noiseSeed = Math.random() * 1000;

  for (let i = 0; i < length; i += 1) {
    const t = i / sampleRate;
    
    noiseSeed = (noiseSeed * 9301 + 49297) % 233280;
    let sample = (noiseSeed / 233280) * 2 - 1;

    const filterEnv = Math.exp(-t * 5);
    sample *= filterEnv;

    let envelope = 1.0;
    if (t < attackTime) {
      envelope = t / attackTime;
    } else {
      envelope = Math.exp(-(t - attackTime) / decayTime);
    }

    sample *= envelope * 0.6;
    data[i] = Math.max(-1, Math.min(1, sample));
  }

  return buffer;
}

/**
 * Generate crashes
 */
function generateCrashes(audioContext: AudioContext): Array<{ metadata: unknown; buffer: AudioBuffer }> {
  const crashes: Array<{ metadata: unknown; buffer: AudioBuffer }> = [];

  for (let i = 1; i <= 5; i += 1) {
    crashes.push({
      metadata: { name: `Crash ${i}`, type: 'crash', category: 'Crashes' },
      buffer: generateCrash(audioContext, { pitch: 3000 + i * 200, decay: 0.5 + i * 0.1 }),
    });
  }

  return crashes;
}

/**
 * Generate crash
 */
function generateCrash(audioContext: AudioContext, params: { pitch: number; decay: number }): AudioBuffer {
  const duration = 1.0;
  const sampleRate = audioContext.sampleRate;
  const length = Math.floor(sampleRate * duration);
  const buffer = audioContext.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);

  const attackTime = 0.01;
  const decayTime = params.decay;

  let noiseSeed = Math.random() * 1000;

  for (let i = 0; i < length; i += 1) {
    const t = i / sampleRate;
    
    noiseSeed = (noiseSeed * 9301 + 49297) % 233280;
    let sample = (noiseSeed / 233280) * 2 - 1;

    const filterEnv = Math.exp(-t * 2);
    sample *= filterEnv;

    let envelope = 1.0;
    if (t < attackTime) {
      envelope = t / attackTime;
    } else {
      envelope = Math.exp(-(t - attackTime) / decayTime);
    }

    sample *= envelope * 0.5;
    data[i] = Math.max(-1, Math.min(1, sample));
  }

  return buffer;
}

/**
 * Generate rides
 */
function generateRides(audioContext: AudioContext): Array<{ metadata: unknown; buffer: AudioBuffer }> {
  const rides: Array<{ metadata: unknown; buffer: AudioBuffer }> = [];

  for (let i = 1; i <= 5; i += 1) {
    rides.push({
      metadata: { name: `Ride ${i}`, type: 'ride', category: 'Rides' },
      buffer: generateRide(audioContext, { pitch: 2000 + i * 150, decay: 0.8 + i * 0.1 }),
    });
  }

  return rides;
}

/**
 * Generate ride
 */
function generateRide(audioContext: AudioContext, params: { pitch: number; decay: number }): AudioBuffer {
  const duration = 1.2;
  const sampleRate = audioContext.sampleRate;
  const length = Math.floor(sampleRate * duration);
  const buffer = audioContext.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);

  const attackTime = 0.005;
  const decayTime = params.decay;

  let noiseSeed = Math.random() * 1000;

  for (let i = 0; i < length; i += 1) {
    const t = i / sampleRate;
    
    noiseSeed = (noiseSeed * 9301 + 49297) % 233280;
    let sample = (noiseSeed / 233280) * 2 - 1;

    const filterEnv = Math.exp(-t * 1.5);
    sample *= filterEnv;

    let envelope = 1.0;
    if (t < attackTime) {
      envelope = t / attackTime;
    } else {
      envelope = Math.exp(-(t - attackTime) / decayTime);
    }

    sample *= envelope * 0.4;
    data[i] = Math.max(-1, Math.min(1, sample));
  }

  return buffer;
}

/**
 * Generate rimshots
 */
function generateRimshots(audioContext: AudioContext): Array<{ metadata: unknown; buffer: AudioBuffer }> {
  const rimshots: Array<{ metadata: unknown; buffer: AudioBuffer }> = [];

  for (let i = 1; i <= 5; i += 1) {
    rimshots.push({
      metadata: { name: `Rimshot ${i}`, type: 'rimshot', category: 'Rimshots' },
      buffer: generateRimshot(audioContext, { tone: 800 + i * 50, decay: 0.1 + i * 0.02 }),
    });
  }

  return rimshots;
}

/**
 * Generate rimshot
 */
function generateRimshot(audioContext: AudioContext, params: { tone: number; decay: number }): AudioBuffer {
  const duration = 0.15;
  const sampleRate = audioContext.sampleRate;
  const length = Math.floor(sampleRate * duration);
  const buffer = audioContext.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);

  const attackTime = 0.001;
  const decayTime = params.decay;

  for (let i = 0; i < length; i += 1) {
    const t = i / sampleRate;
    
    const toneFreq = params.tone;
    const tonePhase = (toneFreq * t * Math.PI * 2) % (Math.PI * 2);
    const toneEnv = Math.exp(-t * 20);
    let sample = Math.sin(tonePhase) * toneEnv;

    const noise = (Math.random() * 2 - 1) * 0.3;
    sample += noise * Math.exp(-t * 15);

    let envelope = 1.0;
    if (t < attackTime) {
      envelope = t / attackTime;
    } else {
      envelope = Math.exp(-(t - attackTime) / decayTime);
    }

    sample *= envelope;
    data[i] = Math.max(-1, Math.min(1, sample));
  }

  return buffer;
}

/**
 * Generate claps
 */
function generateClaps(audioContext: AudioContext): Array<{ metadata: unknown; buffer: AudioBuffer }> {
  const claps: Array<{ metadata: unknown; buffer: AudioBuffer }> = [];

  for (let i = 1; i <= 5; i += 1) {
    claps.push({
      metadata: { name: `Clap ${i}`, type: 'clap', category: 'Claps' },
      buffer: generateClap(audioContext, { delay: 0.01 + i * 0.005, decay: 0.15 + i * 0.02 }),
    });
  }

  return claps;
}

/**
 * Generate clap
 */
function generateClap(audioContext: AudioContext, params: { delay: number; decay: number }): AudioBuffer {
  const duration = 0.3;
  const sampleRate = audioContext.sampleRate;
  const length = Math.floor(sampleRate * duration);
  const buffer = audioContext.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);

  let noiseSeed = Math.random() * 1000;

  for (let i = 0; i < length; i += 1) {
    const t = i / sampleRate;
    
    noiseSeed = (noiseSeed * 9301 + 49297) % 233280;
    let sample = (noiseSeed / 233280) * 2 - 1;

    const delay1 = Math.floor(params.delay * sampleRate);
    const delay2 = Math.floor(params.delay * 1.5 * sampleRate);
    const delay3 = Math.floor(params.delay * 2 * sampleRate);

    if (i >= delay1) {
      const delayedSample = data[i - delay1] || 0;
      sample += delayedSample * 0.3;
    }
    if (i >= delay2) {
      const delayedSample = data[i - delay2] || 0;
      sample += delayedSample * 0.2;
    }
    if (i >= delay3) {
      const delayedSample = data[i - delay3] || 0;
      sample += delayedSample * 0.1;
    }

    const filterEnv = Math.exp(-t * 5);
    sample *= filterEnv;

    const envelope = Math.exp(-t / params.decay);
    sample *= envelope * 0.7;

    data[i] = Math.max(-1, Math.min(1, sample));
  }

  return buffer;
}

/**
 * Convert AudioBuffer to WAV base64 string
 */
function audioBufferToWav(buffer: AudioBuffer): string {
  const length = buffer.length;
  const numberOfChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
  const view = new DataView(arrayBuffer);

  const writeString = (offset: number, string: string): void => {
    for (let i = 0; i < string.length; i += 1) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  };

  writeString(0, 'RIFF');
  view.setUint32(4, 36 + length * numberOfChannels * 2, true);
  writeString(8, 'WAVE');
  writeString(12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numberOfChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * numberOfChannels * 2, true);
  view.setUint16(32, numberOfChannels * 2, true);
  view.setUint16(34, 16, true);
  writeString(36, 'data');
  view.setUint32(40, length * numberOfChannels * 2, true);

  let offset = 44;
  for (let i = 0; i < length; i += 1) {
    for (let channel = 0; channel < numberOfChannels; channel += 1) {
      const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
      view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      offset += 2;
    }
  }

  const bytes = new Uint8Array(arrayBuffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i += 1) {
    binary += String.fromCharCode(bytes[i]);
  }
  return Buffer.from(binary, 'binary').toString('base64');
}

// Run the generator
generateSamples().catch((error) => {
   
  console.error('Failed to generate samples:', error);
  process.exit(1);
});

