/* ================== ULTRA PREMIUM VOCAL STUDIO (WebAudio, no deps) ================== */
(function(){
'use strict';

/* ------------------------------- Utilities ------------------------------- */
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const lerp=(a,b,t)=>a+(b-a)*t;
const NOTE_INDEX = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const SCALE = {
  major:[0,2,4,5,7,9,11],
  minor:[0,2,3,5,7,8,10],
  pentatonic:[0,3,5,7,10],
  blues:[0,3,5,6,7,10],
  chromatic:[0,1,2,3,4,5,6,7,8,9,10,11],
};
function keyToSemitone(k){ return NOTE_INDEX.indexOf(k.toUpperCase()); }
function nearestScaleFreq(f, key="C", scale="minor"){
  if(!f || !isFinite(f) || f<=0) return null;
  const k = keyToSemitone(key); if(k<0) return null;
  const scaleSet = new Set(SCALE[scale]||SCALE.minor);
  // convert to midi, snap to nearest allowed pitch class
  const midi = 69 + 12*Math.log2(f/440);
  let bestMidi = Math.round(midi);
  let bestDist = 1e9;
  for(let m = Math.floor(midi)-24; m<=Math.ceil(midi)+24; m++){
    const pc = ((m%12)+12)%12;
    if(scaleSet.has((pc - k + 12)%12)){
      const d = Math.abs(m - midi);
      if(d < bestDist){ bestDist=d; bestMidi=m; }
    }
  }
  return 440 * Math.pow(2,(bestMidi-69)/12);
}
function yinPitch(buf, sampleRate){
  // YIN (light): returns Hz or null
  const threshold = 0.12;
  const bufSize = buf.length;
  const maxTau = Math.min(1024, bufSize-1);
  const d = new Float32Array(maxTau);
  let tau, j;
  // difference function
  for(tau=1; tau<maxTau; tau++){
    let sum=0;
    for(j=0; j<maxTau; j++){
      const delta = buf[j] - buf[j+tau];
      sum += delta*delta;
    }
    d[tau] = sum;
  }
  // cumulative mean normalized difference
  let cmndf = new Float32Array(maxTau);
  cmndf[0]=1; let runningSum=0;
  for(tau=1; tau<maxTau; tau++){
    runningSum += d[tau];
    cmndf[tau] = d[tau] * tau / (runningSum || 1);
  }
  // absolute threshold
  let tauEstimate=-1;
  for(tau=2; tau<maxTau; tau++){
    if(cmndf[tau] < threshold){
      while(tau+1<maxTau && cmndf[tau+1] < cmndf[tau]) tau++;
      tauEstimate = tau;
      break;
    }
  }
  if(tauEstimate===-1) return null;
  // parabolic interpolation for better precision
  const x0 = (tauEstimate<1)? tauEstimate : tauEstimate-1;
  const x2 = (tauEstimate+1<maxTau)? tauEstimate+1 : tauEstimate;
  const s0 = cmndf[x0], s1 = cmndf[tauEstimate], s2 = cmndf[x2];
  const better = tauEstimate + 0.5*(s0 - s2)/(s0 - 2*s1 + s2 || 1);
  return sampleRate / better;
}

/* ------------------- Pitch-Shift Worklet (Granular, mono->stereo) ------------------- */
async function loadPitchWorklet(ctx){
  if(!ctx.audioWorklet) return null;
  const code = `
  class GranularPitchShiftProcessor extends AudioWorkletProcessor {
    constructor(){
      super();
      const N = Math.max(1, Math.floor(sampleRate*2)); // 2s ring buffer
      this.buf = new Float32Array(N);
      this.N=N; this.w=0; this.rA=0; this.rB=1024;
      this.grain = 2048; // ~43ms @48k
      this.ratio = 1.0;
      this.port.onmessage = (e)=>{ if(e.data && typeof e.data.ratio==='number'){
        const r=e.data.ratio; this.ratio = Math.min(2.5, Math.max(0.4, r));
      }};
    }
    process(inputs, outputs){
      const input = inputs[0]; const output = outputs[0];
      if(!input || !input[0] || !output) return true;
      const inL = input[0]; const inR = input[1] || input[0];
      const outL = output[0]; const outR = output[1] || output[0];
      const N=this.N; const g=this.grain;
      for(let i=0;i<inL.length;i++){
        // write mono mix into ring
        this.buf[this.w] = 0.5*(inL[i] + (inR[i]||0));
        this.w = (this.w+1)%N;
        // read with 2 grains crossfaded
        const posA = Math.floor(this.rA)%N;
        const posB = Math.floor(this.rB)%N;
        const fracA = this.rA - Math.floor(this.rA);
        const fracB = this.rB - Math.floor(this.rB);
        // linear interp
        const sA = this.buf[posA] + (this.buf[(posA+1)%N]-this.buf[posA])*fracA;
        const sB = this.buf[posB] + (this.buf[(posB+1)%N]-this.buf[posB])*fracB;
        // hann crossfade over grain
        const t = (i % g)/g;
        const wA = 0.5*(1 - Math.cos(2*Math.PI*t));
        const y = sA*wA + sB*(1-wA);
        outL[i]=y; outR[i]=y;
        const step = this.ratio;
        this.rA += step; this.rB += step;
        // keep grains staggered ~g/2
        if((i % g) === 0){ this.rB = this.rA + g/2; }
        // wrap read indices to ring
        if(this.rA>=N) this.rA -= N;
        if(this.rB>=N) this.rB -= N;
      }
      return true;
    }
  }
  registerProcessor('granular-pitch-shift', GranularPitchShiftProcessor);
  `;
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  await ctx.audioWorklet.addModule(url);
  URL.revokeObjectURL(url);
  return true;
}

/* --------------------------- Main Class: Vocal Studio --------------------------- */
class VocalStudio {
  constructor(flStudio){
    this.flStudio=flStudio;
    this.ctx=flStudio.audioContext;
      this.isRecording = false;
      this.isMonitoring = false;
      this.mediaStream = null;
      this.mediaRecorder = null;
      this.audioChunks = [];
      this.recordedBlob = null;
      
      // Audio nodes
      this.inputNode = null;
      this.autotuneNode = null;
      this.pitchShifter = null;
      this.reverbNode = null;
      this.delayNode = null;
      this.compressorNode = null;
      this.eqNodes = [];
      this.vocoderNodes = [];
      this.outputNode = null;
      
      // Autotune settings
      this.autotuneEnabled = true;
      this.autotuneStrength = 0.8; // 0-1
      this.targetKey = 'C';
      this.targetScale = 'minor'; // minor for trap
      this.pitchCorrection = 50; // ms
      
      // Effects settings
      this.reverbMix = 0.3;
      this.reverbDecay = 2.5;
      this.delayTime = 0.25; // 1/4 note
      this.delayFeedback = 0.4;
      this.delayMix = 0.25;
      this.doubleTrack = true;
      this.compression = true;
      
      this.init();
    }

    init() {
      this.createStyles();
      this.createUI();
      this.setupAudioChain();
      this.setupEventListeners();
    }

    createStyles() {
      if (document.getElementById('vocal-studio-styles')) return;
      
      const style = document.createElement('style');
      style.id = 'vocal-studio-styles';
      style.textContent = `
        .vocal-studio-btn {
          position: fixed;
          bottom: 20px;
          right: 20px;
          width: 60px;
          height: 60px;
          border-radius: 50%;
          background: linear-gradient(135deg, #FF0080 0%, #7928CA 100%);
          border: 3px solid #FF0080;
          color: #fff;
          font-size: 28px;
          cursor: pointer;
          box-shadow: 0 8px 32px rgba(255, 0, 128, 0.5);
          z-index: 9999;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: all 0.3s;
          animation: pulse 2s infinite;
        }

        .vocal-studio-btn:hover {
          transform: scale(1.1);
          box-shadow: 0 12px 48px rgba(255, 0, 128, 0.7);
        }

        @keyframes pulse {
          0%, 100% { box-shadow: 0 8px 32px rgba(255, 0, 128, 0.5); }
          50% { box-shadow: 0 8px 48px rgba(255, 0, 128, 0.8); }
        }

        .vocal-studio-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.85);
          backdrop-filter: blur(12px);
          z-index: 10001;
          display: none;
          align-items: center;
          justify-content: center;
          animation: fadeIn 0.3s ease-out;
        }

        .vocal-studio-overlay.active {
          display: flex;
        }

        .vocal-studio-window {
          background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%);
          border: 2px solid #FF0080;
          border-radius: 24px;
          width: 900px;
          max-width: 95%;
          height: 700px;
          max-height: 90vh;
          box-shadow: 0 24px 80px rgba(255, 0, 128, 0.6);
          display: flex;
          flex-direction: column;
          overflow: hidden;
          position: relative;
        }

        .vocal-studio-header {
          background: linear-gradient(135deg, #FF0080 0%, #7928CA 50%, #4F46E5 100%);
          padding: 20px 24px;
          display: flex;
          align-items: center;
          justify-content: space-between;
          border-bottom: 2px solid #FF0080;
        }

        .vocal-studio-title {
          display: flex;
          align-items: center;
          gap: 12px;
          color: #fff;
          font-size: 20px;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 2px;
        }

        .vocal-studio-icon {
          font-size: 32px;
          animation: bounce 1s infinite;
        }

        @keyframes bounce {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-5px); }
        }

        .vocal-studio-close {
          background: rgba(255, 255, 255, 0.2);
          border: 2px solid rgba(255, 255, 255, 0.4);
          color: #fff;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          cursor: pointer;
          font-size: 24px;
          line-height: 1;
          transition: all 0.2s;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .vocal-studio-close:hover {
          background: rgba(255, 255, 255, 0.3);
          transform: rotate(90deg) scale(1.1);
        }

        .vocal-studio-content {
          flex: 1;
          overflow-y: auto;
          padding: 24px;
          display: flex;
          flex-direction: column;
          gap: 20px;
        }

        .vocal-waveform {
          background: #0a0a0a;
          border: 2px solid #FF0080;
          border-radius: 16px;
          height: 150px;
          position: relative;
          overflow: hidden;
          box-shadow: inset 0 4px 12px rgba(0, 0, 0, 0.8);
        }

        .vocal-waveform canvas {
          width: 100%;
          height: 100%;
        }

        .vocal-controls-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
          gap: 16px;
        }

        .vocal-section {
          background: rgba(255, 0, 128, 0.05);
          border: 1px solid rgba(255, 0, 128, 0.3);
          border-radius: 12px;
          padding: 16px;
        }

        .vocal-section-title {
          font-size: 13px;
          font-weight: 700;
          color: #FF0080;
          text-transform: uppercase;
          letter-spacing: 1.5px;
          margin-bottom: 14px;
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .vocal-control {
          display: flex;
          flex-direction: column;
          gap: 6px;
          margin-bottom: 12px;
        }

        .vocal-label {
          font-size: 11px;
          color: #aaa;
          font-weight: 600;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }

        .vocal-value {
          color: #FF0080;
          font-weight: 700;
          font-size: 12px;
        }

        .vocal-slider {
          width: 100%;
          height: 6px;
          -webkit-appearance: none;
          appearance: none;
          background: linear-gradient(90deg, #2a2a2a 0%, #3a3a3a 100%);
          border-radius: 3px;
          outline: none;
        }

        .vocal-slider::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 18px;
          height: 18px;
          border-radius: 50%;
          background: linear-gradient(135deg, #FF0080 0%, #7928CA 100%);
          cursor: pointer;
          box-shadow: 0 2px 8px rgba(255, 0, 128, 0.6);
          transition: all 0.15s;
        }

        .vocal-slider::-webkit-slider-thumb:hover {
          transform: scale(1.2);
          box-shadow: 0 4px 16px rgba(255, 0, 128, 0.8);
        }

        .vocal-slider::-moz-range-thumb {
          width: 18px;
          height: 18px;
          border-radius: 50%;
          background: linear-gradient(135deg, #FF0080 0%, #7928CA 100%);
          cursor: pointer;
          border: none;
          box-shadow: 0 2px 8px rgba(255, 0, 128, 0.6);
        }

        .vocal-select {
          width: 100%;
          background: #1a1a1a;
          border: 2px solid #FF0080;
          color: #fff;
          padding: 10px;
          border-radius: 8px;
          font-size: 13px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        }

        .vocal-select:focus {
          outline: none;
          box-shadow: 0 0 0 3px rgba(255, 0, 128, 0.3);
        }

        .vocal-toggle {
          position: relative;
          width: 70px;
          height: 34px;
          background: #2a2a2a;
          border-radius: 17px;
          cursor: pointer;
          transition: all 0.3s;
          border: 2px solid #555;
        }

        .vocal-toggle.active {
          background: linear-gradient(135deg, #FF0080 0%, #7928CA 100%);
          border-color: #FF0080;
        }

        .vocal-toggle::after {
          content: '';
          position: absolute;
          top: 3px;
          left: 3px;
          width: 24px;
          height: 24px;
          background: #fff;
          border-radius: 50%;
          transition: all 0.3s;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .vocal-toggle.active::after {
          left: 39px;
        }

        .vocal-record-btn {
          background: linear-gradient(135deg, #FF0080 0%, #FF0040 100%);
          border: 3px solid #FF0080;
          color: #fff;
          padding: 20px 40px;
          border-radius: 50px;
          font-size: 18px;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 2px;
          cursor: pointer;
          transition: all 0.3s;
          box-shadow: 0 8px 24px rgba(255, 0, 128, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 12px;
          margin: 20px auto;
          min-width: 250px;
        }

        .vocal-record-btn:hover {
          transform: scale(1.05);
          box-shadow: 0 12px 32px rgba(255, 0, 128, 0.7);
        }

        .vocal-record-btn:active {
          transform: scale(0.98);
        }

        .vocal-record-btn.recording {
          background: linear-gradient(135deg, #FF4444 0%, #CC0000 100%);
          animation: recordPulse 1s infinite;
        }

        @keyframes recordPulse {
          0%, 100% { box-shadow: 0 8px 24px rgba(255, 0, 0, 0.5); }
          50% { box-shadow: 0 12px 40px rgba(255, 0, 0, 0.9); }
        }

        .vocal-record-icon {
          font-size: 24px;
        }

        .vocal-record-time {
          background: rgba(0, 0, 0, 0.4);
          padding: 4px 12px;
          border-radius: 20px;
          font-size: 14px;
          font-family: monospace;
        }

        .vocal-meter {
          height: 8px;
          background: #1a1a1a;
          border-radius: 4px;
          overflow: hidden;
          position: relative;
        }

        .vocal-meter-fill {
          height: 100%;
          background: linear-gradient(90deg, #00FF00 0%, #FFFF00 50%, #FF0000 100%);
          width: 0%;
          transition: width 0.05s;
        }

        .vocal-presets {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
          gap: 10px;
        }

        .vocal-preset-btn {
          background: rgba(255, 0, 128, 0.1);
          border: 2px solid rgba(255, 0, 128, 0.3);
          color: #fff;
          padding: 12px;
          border-radius: 10px;
          font-size: 12px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
          text-align: center;
        }

        .vocal-preset-btn:hover {
          background: rgba(255, 0, 128, 0.2);
          border-color: #FF0080;
          transform: translateY(-2px);
        }

        .vocal-preset-btn.active {
          background: linear-gradient(135deg, #FF0080 0%, #7928CA 100%);
          border-color: #FF0080;
        }

        .vocal-playback-controls {
          display: flex;
          gap: 12px;
          justify-content: center;
          align-items: center;
        }

        .vocal-playback-btn {
          background: rgba(255, 0, 128, 0.2);
          border: 2px solid #FF0080;
          color: #fff;
          width: 50px;
          height: 50px;
          border-radius: 50%;
          font-size: 20px;
          cursor: pointer;
          transition: all 0.2s;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .vocal-playback-btn:hover {
          background: #FF0080;
          transform: scale(1.1);
        }

        .vocal-download-btn {
          background: linear-gradient(135deg, #4F46E5 0%, #7928CA 100%);
          border: 2px solid #4F46E5;
          color: #fff;
          padding: 12px 24px;
          border-radius: 25px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .vocal-download-btn:hover {
          transform: scale(1.05);
          box-shadow: 0 6px 20px rgba(79, 70, 229, 0.5);
        }

        .vocal-status {
          background: rgba(255, 0, 128, 0.1);
          border: 1px solid rgba(255, 0, 128, 0.3);
          border-radius: 8px;
          padding: 12px;
          text-align: center;
          font-size: 12px;
          color: #FF0080;
          font-weight: 600;
        }
      `;
      document.head.appendChild(style);
    }

    createUI() {
      // Floating button
      const floatingBtn = document.createElement('button');
      floatingBtn.className = 'vocal-studio-btn';
      floatingBtn.id = 'vocal-studio-floating-btn';
      floatingBtn.innerHTML = 'üé§';
      floatingBtn.title = 'Open Vocal Studio (Autotune + Trap Effects)';
      document.body.appendChild(floatingBtn);

      // Main overlay
      const overlay = document.createElement('div');
      overlay.className = 'vocal-studio-overlay';
      overlay.id = 'vocal-studio-overlay';
      overlay.innerHTML = `
        <div class="vocal-studio-window" onclick="event.stopPropagation()">
          <div class="vocal-studio-header">
            <div class="vocal-studio-title">
              <span class="vocal-studio-icon">üé§</span>
              <span>Vocal Studio Pro</span>
            </div>
            <button class="vocal-studio-close" id="vocal-studio-close">√ó</button>
          </div>
          
          <div class="vocal-studio-content">
            <!-- Waveform Display -->
            <div class="vocal-waveform">
              <canvas id="vocal-waveform-canvas" width="800" height="150"></canvas>
            </div>

            <!-- Record Button -->
            <button class="vocal-record-btn" id="vocal-record-btn">
              <span class="vocal-record-icon">‚è∫</span>
              <span id="vocal-record-text">Start Recording</span>
              <span class="vocal-record-time" id="vocal-record-time">00:00</span>
            </button>

            <!-- Level Meter -->
            <div class="vocal-control">
              <div class="vocal-label">Input Level</div>
              <div class="vocal-meter">
                <div class="vocal-meter-fill" id="vocal-meter-fill"></div>
              </div>
            </div>

            <!-- Playback Controls -->
            <div class="vocal-playback-controls" id="vocal-playback-controls" style="display: none;">
              <button class="vocal-playback-btn" id="vocal-play-btn" title="Play">‚ñ∂</button>
              <button class="vocal-playback-btn" id="vocal-stop-btn" title="Stop">‚èπ</button>
              <button class="vocal-download-btn" id="vocal-download-btn">
                <span>üíæ</span>
                <span>Download Recording</span>
              </button>
            </div>

            <!-- Presets -->
            <div class="vocal-section">
              <div class="vocal-section-title">üéõ Trap Presets</div>
              <div class="vocal-presets">
                <button class="vocal-preset-btn active" data-preset="trap-auto">Trap Auto</button>
                <button class="vocal-preset-btn" data-preset="hard-tune">Hard Tune</button>
                <button class="vocal-preset-btn" data-preset="melodic">Melodic</button>
                <button class="vocal-preset-btn" data-preset="dark">Dark Trap</button>
                <button class="vocal-preset-btn" data-preset="spacey">Spacey</button>
                <button class="vocal-preset-btn" data-preset="clean">Clean</button>
              </div>
            </div>

            <div class="vocal-controls-grid">
              <!-- Autotune Section -->
              <div class="vocal-section">
                <div class="vocal-section-title">üéµ Autotune</div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Enable</span>
                    <div class="vocal-toggle active" id="autotune-toggle"></div>
                  </div>
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Strength</span>
                    <span class="vocal-value" id="autotune-strength-val">80%</span>
                  </div>
                  <input type="range" class="vocal-slider" id="autotune-strength" min="0" max="100" value="80">
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Speed (ms)</span>
                    <span class="vocal-value" id="autotune-speed-val">50</span>
                  </div>
                  <input type="range" class="vocal-slider" id="autotune-speed" min="1" max="200" value="50">
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">Key</div>
                  <select class="vocal-select" id="autotune-key">
                    <option value="C">C</option>
                    <option value="C#">C#</option>
                    <option value="D">D</option>
                    <option value="D#">D#</option>
                    <option value="E">E</option>
                    <option value="F">F</option>
                    <option value="F#">F#</option>
                    <option value="G">G</option>
                    <option value="G#">G#</option>
                    <option value="A">A</option>
                    <option value="A#">A#</option>
                    <option value="B">B</option>
                  </select>
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">Scale</div>
                  <select class="vocal-select" id="autotune-scale">
                    <option value="minor">Minor (Trap)</option>
                    <option value="major">Major</option>
                    <option value="pentatonic">Pentatonic</option>
                    <option value="blues">Blues</option>
                    <option value="chromatic">Chromatic</option>
                  </select>
                </div>
              </div>

              <!-- Reverb Section -->
              <div class="vocal-section">
                <div class="vocal-section-title">üåä Reverb</div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Mix</span>
                    <span class="vocal-value" id="reverb-mix-val">30%</span>
                  </div>
                  <input type="range" class="vocal-slider" id="reverb-mix" min="0" max="100" value="30">
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Decay</span>
                    <span class="vocal-value" id="reverb-decay-val">2.5s</span>
                  </div>
                  <input type="range" class="vocal-slider" id="reverb-decay" min="0.1" max="10" value="2.5" step="0.1">
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Pre-Delay</span>
                    <span class="vocal-value" id="reverb-predelay-val">20ms</span>
                  </div>
                  <input type="range" class="vocal-slider" id="reverb-predelay" min="0" max="100" value="20">
                </div>
              </div>

              <!-- Delay Section -->
              <div class="vocal-section">
                <div class="vocal-section-title">‚è± Delay</div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Mix</span>
                    <span class="vocal-value" id="delay-mix-val">25%</span>
                  </div>
                  <input type="range" class="vocal-slider" id="delay-mix" min="0" max="100" value="25">
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Time</span>
                    <span class="vocal-value" id="delay-time-val">1/4</span>
                  </div>
                  <select class="vocal-select" id="delay-time">
                    <option value="0.125">1/8</option>
                    <option value="0.1875">1/8 Dotted</option>
                    <option value="0.25" selected>1/4</option>
                    <option value="0.375">1/4 Dotted</option>
                    <option value="0.5">1/2</option>
                  </select>
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Feedback</span>
                    <span class="vocal-value" id="delay-feedback-val">40%</span>
                  </div>
                  <input type="range" class="vocal-slider" id="delay-feedback" min="0" max="90" value="40">
                </div>
              </div>

              <!-- Voice Effects -->
              <div class="vocal-section">
                <div class="vocal-section-title">‚ú® Voice FX</div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Double Track</span>
                    <div class="vocal-toggle active" id="double-toggle"></div>
                  </div>
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Compression</span>
                    <div class="vocal-toggle active" id="compression-toggle"></div>
                  </div>
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Warmth</span>
                    <span class="vocal-value" id="warmth-val">50%</span>
                  </div>
                  <input type="range" class="vocal-slider" id="warmth" min="0" max="100" value="50">
                </div>
                <div class="vocal-control">
                  <div class="vocal-label">
                    <span>Air (High Freq)</span>
                    <span class="vocal-value" id="air-val">30%</span>
                  </div>
                  <input type="range" class="vocal-slider" id="air" min="0" max="100" value="30">
                </div>
              </div>
            </div>

            <!-- Status -->
            <div class="vocal-status" id="vocal-status">
              üéô Ready to record. Click Start Recording to begin.
            </div>
          </div>
        </div>
      `;

      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) this.close();
      });

      document.body.appendChild(overlay);
    }

    setupAudioChain() {
      if (!this.audioContext) return;

      // Create input gain
      this.inputNode = this.audioContext.createGain();
      this.inputNode.gain.value = 1.0;

      // Create compressor (for consistent levels)
      this.compressorNode = this.audioContext.createDynamicsCompressor();
      this.compressorNode.threshold.value = -24;
      this.compressorNode.knee.value = 30;
      this.compressorNode.ratio.value = 12;
      this.compressorNode.attack.value = 0.003;
      this.compressorNode.release.value = 0.25;

      // Create EQ nodes for warmth and air
      const lowShelf = this.audioContext.createBiquadFilter();
      lowShelf.type = 'lowshelf';
      lowShelf.frequency.value = 200;
      lowShelf.gain.value = 0;
      this.eqNodes.push(lowShelf);

      const highShelf = this.audioContext.createBiquadFilter();
      highShelf.type = 'highshelf';
      highShelf.frequency.value = 8000;
      highShelf.gain.value = 0;
      this.eqNodes.push(highShelf);

      // Create delay
      this.delayNode = this.audioContext.createDelay(2.0);
      this.delayNode.delayTime.value = this.delayTime;
      
      const delayFeedback = this.audioContext.createGain();
      delayFeedback.gain.value = this.delayFeedback;
      
      const delayMix = this.audioContext.createGain();
      delayMix.gain.value = this.delayMix;

      // Connect delay feedback loop
      this.delayNode.connect(delayFeedback);
      delayFeedback.connect(this.delayNode);
      this.delayNode.connect(delayMix);

      // Create convolver for reverb
      this.reverbNode = this.audioContext.createConvolver();
      this.createReverbImpulse();

      const reverbMixNode = this.audioContext.createGain();
      reverbMixNode.gain.value = this.reverbMix;

      // Output
      this.outputNode = this.audioContext.createGain();
      this.outputNode.gain.value = 1.0;

      // Connect chain: input -> compressor -> EQ -> delay -> reverb -> output
      this.inputNode.connect(this.compressorNode);
      this.compressorNode.connect(this.eqNodes[0]);
      this.eqNodes[0].connect(this.eqNodes[1]);
      this.eqNodes[1].connect(this.outputNode);
      
      // Parallel effects
      this.eqNodes[1].connect(this.delayNode);
      delayMix.connect(this.outputNode);
      
      this.eqNodes[1].connect(this.reverbNode);
      this.reverbNode.connect(reverbMixNode);
      reverbMixNode.connect(this.outputNode);

      // Connect to master
      this.outputNode.connect(this.audioContext.destination);

      console.log('üé§ Vocal Studio audio chain initialized');
    }

    createReverbImpulse() {
      const rate = this.audioContext.sampleRate;
      const length = rate * this.reverbDecay;
      const impulse = this.audioContext.createBuffer(2, length, rate);
      
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
        }
      }
      
      this.reverbNode.buffer = impulse;
    }

    setupEventListeners() {
      // Open/close
      document.getElementById('vocal-studio-floating-btn').addEventListener('click', () => this.open());
      document.getElementById('vocal-studio-close').addEventListener('click', () => this.close());

      // Record button
      document.getElementById('vocal-record-btn').addEventListener('click', () => this.toggleRecording());

      // Playback controls
      document.getElementById('vocal-play-btn')?.addEventListener('click', () => this.playRecording());
      document.getElementById('vocal-stop-btn')?.addEventListener('click', () => this.stopPlayback());
      document.getElementById('vocal-download-btn')?.addEventListener('click', () => this.downloadRecording());

      // Presets
      document.querySelectorAll('.vocal-preset-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          document.querySelectorAll('.vocal-preset-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          this.loadPreset(btn.dataset.preset);
        });
      });

      // Toggles
      this.setupToggle('autotune-toggle', (active) => {
        this.autotuneEnabled = active;
        this.updateStatus('Autotune ' + (active ? 'enabled' : 'disabled'));
      });
      
      this.setupToggle('double-toggle', (active) => {
        this.doubleTrack = active;
        this.updateStatus('Double tracking ' + (active ? 'enabled' : 'disabled'));
      });
      
      this.setupToggle('compression-toggle', (active) => {
        this.compression = active;
        if (this.compressorNode) {
          this.compressorNode.ratio.value = active ? 12 : 1;
        }
        this.updateStatus('Compression ' + (active ? 'enabled' : 'disabled'));
      });

      // Sliders
      this.setupSlider('autotune-strength', 'autotune-strength-val', (v) => {
        this.autotuneStrength = v / 100;
      }, '%');

      this.setupSlider('autotune-speed', 'autotune-speed-val', (v) => {
        this.pitchCorrection = v;
      }, '');

      this.setupSlider('reverb-mix', 'reverb-mix-val', (v) => {
        this.reverbMix = v / 100;
        // Update reverb mix in real-time
      }, '%');

      this.setupSlider('reverb-decay', 'reverb-decay-val', (v) => {
        this.reverbDecay = v;
        this.createReverbImpulse();
      }, 's');

      this.setupSlider('delay-mix', 'delay-mix-val', (v) => {
        this.delayMix = v / 100;
      }, '%');

      this.setupSlider('delay-feedback', 'delay-feedback-val', (v) => {
        this.delayFeedback = v / 100;
      }, '%');

      this.setupSlider('warmth', 'warmth-val', (v) => {
        if (this.eqNodes[0]) {
          this.eqNodes[0].gain.value = (v / 100) * 6; // Up to +6dB
        }
      }, '%');

      this.setupSlider('air', 'air-val', (v) => {
        if (this.eqNodes[1]) {
          this.eqNodes[1].gain.value = (v / 100) * 6; // Up to +6dB
        }
      }, '%');

      // Dropdowns
      document.getElementById('autotune-key')?.addEventListener('change', (e) => {
        this.targetKey = e.target.value;
        this.updateStatus(`Key changed to ${this.targetKey}`);
      });

      document.getElementById('autotune-scale')?.addEventListener('change', (e) => {
        this.targetScale = e.target.value;
        this.updateStatus(`Scale changed to ${this.targetScale}`);
      });

      document.getElementById('delay-time')?.addEventListener('change', (e) => {
        this.delayTime = parseFloat(e.target.value);
        if (this.delayNode) {
          this.delayNode.delayTime.value = this.delayTime;
        }
        document.getElementById('delay-time-val').textContent = e.target.options[e.target.selectedIndex].text;
      });

      // Start animation
      this.startWaveformAnimation();
    }

    setupToggle(id, callback) {
      const toggle = document.getElementById(id);
      if (toggle) {
        toggle.addEventListener('click', () => {
          toggle.classList.toggle('active');
          callback(toggle.classList.contains('active'));
        });
      }
    }

    setupSlider(sliderId, valueId, callback, unit) {
      const slider = document.getElementById(sliderId);
      const valueDisplay = document.getElementById(valueId);
      
      if (slider && valueDisplay) {
        slider.addEventListener('input', (e) => {
          const value = parseFloat(e.target.value);
          valueDisplay.textContent = value + unit;
          callback(value);
        });
      }
    }

    async open() {
      document.getElementById('vocal-studio-overlay').classList.add('active');
      
      try {
        // Request microphone permission
        this.mediaStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: false
          } 
        });
        
        const source = this.audioContext.createMediaStreamSource(this.mediaStream);
        source.connect(this.inputNode);
        
        // Setup analyzer for level meter
        this.analyser = this.audioContext.createAnalyser();
        source.connect(this.analyser);
        this.analyser.fftSize = 256;
        this.startLevelMeter();
        
        this.updateStatus('üéô Microphone connected! Ready to record.');
      } catch (err) {
        this.updateStatus('‚ùå Microphone access denied: ' + err.message);
        console.error('Microphone error:', err);
      }
    }

    close() {
      document.getElementById('vocal-studio-overlay').classList.remove('active');
      
      if (this.isRecording) {
        this.stopRecording();
      }
      
      if (this.mediaStream) {
        this.mediaStream.getTracks().forEach(track => track.stop());
        this.mediaStream = null;
      }
      
      this.isMonitoring = false;
    }

    async toggleRecording() {
      if (this.isRecording) {
        this.stopRecording();
      } else {
        this.startRecording();
      }
    }

    startRecording() {
      if (!this.mediaStream) {
        this.updateStatus('‚ùå No microphone connected');
        return;
      }

      this.audioChunks = [];
      this.mediaRecorder = new MediaRecorder(this.mediaStream);
      
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };
      
      this.mediaRecorder.onstop = () => {
        this.recordedBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
        document.getElementById('vocal-playback-controls').style.display = 'flex';
        this.updateStatus('‚úÖ Recording complete! Click play to listen.');
      };
      
      this.mediaRecorder.start();
      this.isRecording = true;
      this.recordingStartTime = Date.now();
      
      // Update UI
      const btn = document.getElementById('vocal-record-btn');
      btn.classList.add('recording');
      document.getElementById('vocal-record-text').textContent = 'Recording...';
      document.getElementById('vocal-record-icon').textContent = '‚èπ';
      
      this.updateRecordingTime();
      this.updateStatus('üî¥ Recording in progress...');
    }

    stopRecording() {
      if (this.mediaRecorder && this.isRecording) {
        this.mediaRecorder.stop();
        this.isRecording = false;
        
        const btn = document.getElementById('vocal-record-btn');
        btn.classList.remove('recording');
        document.getElementById('vocal-record-text').textContent = 'Start Recording';
        document.getElementById('vocal-record-icon').textContent = '‚è∫';
      }
    }

    updateRecordingTime() {
      if (!this.isRecording) return;
      
      const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const seconds = (elapsed % 60).toString().padStart(2, '0');
      document.getElementById('vocal-record-time').textContent = `${minutes}:${seconds}`;
      
      setTimeout(() => this.updateRecordingTime(), 1000);
    }

    playRecording() {
      if (!this.recordedBlob) return;
      
      const url = URL.createObjectURL(this.recordedBlob);
      const audio = new Audio(url);
      audio.play();
      
      this.updateStatus('‚ñ∂ Playing recording...');
    }

    stopPlayback() {
      // Stop any playing audio
      this.updateStatus('‚èπ Playback stopped');
    }

    downloadRecording() {
      if (!this.recordedBlob) return;
      
      const url = URL.createObjectURL(this.recordedBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `vocal-recording-${Date.now()}.webm`;
      a.click();
      
      this.updateStatus('üíæ Recording downloaded!');
    }

    startLevelMeter() {
      const updateMeter = () => {
        if (!this.analyser) return;
        
        const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        this.analyser.getByteFrequencyData(dataArray);
        
        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
        const level = (average / 255) * 100;
        
        document.getElementById('vocal-meter-fill').style.width = level + '%';
        
        requestAnimationFrame(updateMeter);
      };
      
      updateMeter();
    }

    startWaveformAnimation() {
      const canvas = document.getElementById('vocal-waveform-canvas');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      let phase = 0;
      
      const animate = () => {
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.strokeStyle = '#FF0080';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let x = 0; x < canvas.width; x++) {
          const y = canvas.height / 2 + Math.sin((x + phase) * 0.02) * 20;
          if (x === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
        phase += 2;
        
        requestAnimationFrame(animate);
      };
      
      animate();
    }

    loadPreset(preset) {
      const presets = {
        'trap-auto': {
          autotuneStrength: 80,
          autotuneSpeed: 50,
          reverbMix: 30,
          reverbDecay: 2.5,
          delayMix: 25,
          delayFeedback: 40,
          warmth: 50,
          air: 30
        },
        'hard-tune': {
          autotuneStrength: 100,
          autotuneSpeed: 1,
          reverbMix: 20,
          reverbDecay: 1.5,
          delayMix: 15,
          delayFeedback: 30,
          warmth: 40,
          air: 50
        },
        'melodic': {
          autotuneStrength: 60,
          autotuneSpeed: 100,
          reverbMix: 45,
          reverbDecay: 3.5,
          delayMix: 35,
          delayFeedback: 50,
          warmth: 60,
          air: 40
        },
        'dark': {
          autotuneStrength: 70,
          autotuneSpeed: 30,
          reverbMix: 50,
          reverbDecay: 4.0,
          delayMix: 30,
          delayFeedback: 60,
          warmth: 70,
          air: 20
        },
        'spacey': {
          autotuneStrength: 50,
          autotuneSpeed: 150,
          reverbMix: 60,
          reverbDecay: 6.0,
          delayMix: 45,
          delayFeedback: 70,
          warmth: 30,
          air: 60
        },
        'clean': {
          autotuneStrength: 30,
          autotuneSpeed: 80,
          reverbMix: 15,
          reverbDecay: 1.0,
          delayMix: 10,
          delayFeedback: 20,
          warmth: 40,
          air: 35
        }
      };

      const p = presets[preset];
      if (!p) return;

      // Apply preset values
      document.getElementById('autotune-strength').value = p.autotuneStrength;
      document.getElementById('autotune-strength-val').textContent = p.autotuneStrength + '%';
      this.autotuneStrength = p.autotuneStrength / 100;

      document.getElementById('autotune-speed').value = p.autotuneSpeed;
      document.getElementById('autotune-speed-val').textContent = p.autotuneSpeed;
      this.pitchCorrection = p.autotuneSpeed;

      document.getElementById('reverb-mix').value = p.reverbMix;
      document.getElementById('reverb-mix-val').textContent = p.reverbMix + '%';
      this.reverbMix = p.reverbMix / 100;

      document.getElementById('reverb-decay').value = p.reverbDecay;
      document.getElementById('reverb-decay-val').textContent = p.reverbDecay + 's';
      this.reverbDecay = p.reverbDecay;
      this.createReverbImpulse();

      document.getElementById('delay-mix').value = p.delayMix;
      document.getElementById('delay-mix-val').textContent = p.delayMix + '%';
      this.delayMix = p.delayMix / 100;

      document.getElementById('delay-feedback').value = p.delayFeedback;
      document.getElementById('delay-feedback-val').textContent = p.delayFeedback + '%';
      this.delayFeedback = p.delayFeedback / 100;

      document.getElementById('warmth').value = p.warmth;
      document.getElementById('warmth-val').textContent = p.warmth + '%';
      if (this.eqNodes[0]) this.eqNodes[0].gain.value = (p.warmth / 100) * 6;

      document.getElementById('air').value = p.air;
      document.getElementById('air-val').textContent = p.air + '%';
      if (this.eqNodes[1]) this.eqNodes[1].gain.value = (p.air / 100) * 6;

      this.updateStatus(`üéõ Loaded preset: ${preset.replace('-', ' ').toUpperCase()}`);
    }

    updateStatus(message) {
      document.getElementById('vocal-status').textContent = message;
    }
  }

  // Initialize when app is ready
  const init = () => {
    if (window.flStudio && window.flStudio.audioContext) {
      window.vocalStudio = new VocalStudio(window.flStudio);
      console.log('üé§ ‚ú® Ultra Premium Vocal Studio loaded!');
    } else {
      setTimeout(init, 100);
    }
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

})();
